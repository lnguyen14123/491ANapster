<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Napster | Home Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Fonts / Icons / AdminLTE -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@fontsource/source-sans-3@5.0.12/index.css"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/overlaysscrollbars@2.10.1/styles/overlayscrollbars.min.css"
    />
    <link rel="stylesheet" href="./dist/css/adminlte.css" />
    <link
      rel="icon"
      type="image/png"
      href="./dist/assets/img/napsterlogo.png"
    />

    <style>
      :root {
        /* Light purple theme */
        --violet: #8b5cf6;
        --violet-600: #7c3aed;
        --violet-400: #a78bfa;
        --violet-300: #c4b5fd;
        --violet-100: #ede9fe;

        --ink: #0f172a;
        --muted: #6b7280;
        --glass: rgba(255, 255, 255, 0.6);
        --ring-bg: #ffffff;
      }

      /* Gradient canvas + ambient blobs */
      .app-main {
        background: radial-gradient(
            1200px 600px at 10% -10%,
            rgba(139, 92, 246, 0.15),
            transparent 60%
          ),
          radial-gradient(
            800px 500px at 110% 20%,
            rgba(196, 181, 253, 0.22),
            transparent 60%
          ),
          linear-gradient(180deg, #f8fafc 0%, #eef2ff 100%);
        min-height: 100vh;
      }
      .ambient {
        position: absolute;
        inset: 0;
        pointer-events: none;
        overflow: hidden;
      }
      .blob {
        position: absolute;
        border-radius: 9999px;
        filter: blur(40px);
        opacity: 0.4;
        animation: float 18s ease-in-out infinite;
      }
      .blob.violet {
        width: 360px;
        height: 360px;
        background: #c4b5fd;
        left: 10%;
        top: 20%;
      }
      .blob.sky {
        width: 420px;
        height: 420px;
        background: #ede9fe;
        right: 8%;
        bottom: 10%;
        animation-delay: -6s;
      }
      @keyframes float {
        0%,
        100% {
          transform: translateY(0) translateX(0);
        }
        50% {
          transform: translateY(-20px) translateX(10px);
        }
      }

      /* Center stage */
      .center-wrap {
        position: relative;
        z-index: 2;
        min-height: calc(100vh - 112px);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 2.5rem 1rem;
      }

      /* Glass card frame */
      .glass {
        width: min(1020px, 95vw);
        display: grid;
        grid-template-columns: 1.1fr 0.9fr;
        gap: 28px;
        background: var(--glass);
        backdrop-filter: blur(10px) saturate(1.1);
        border: 1px solid rgba(139, 92, 246, 0.18);
        box-shadow: 0 20px 60px rgba(2, 6, 23, 0.08);
        border-radius: 24px;
        padding: 24px;
      }
      @media (max-width: 900px) {
        .glass {
          grid-template-columns: 1fr;
        }
      }

      /* Circular timer (violet) */
      .nap-circle {
        aspect-ratio: 1/1;
        width: 420px;
        max-width: 100%;
        margin-inline: auto;
        border-radius: 50%;
        display: grid;
        place-items: center;
        position: relative;
        background: radial-gradient(
            closest-side,
            var(--ring-bg) 69%,
            transparent 70% 71%,
            #f2ecff 0
          ),
          conic-gradient(
            var(--progress, 0%),
            var(--violet),
            var(--violet-400) 40%,
            var(--violet-300) 70%,
            var(--violet-100)
          );
        box-shadow: 0 16px 48px rgba(124, 58, 237, 0.24);
        animation: breathe 4.5s ease-in-out infinite;
        animation-play-state: paused; /* run only while timer is running */
      }
      .nap-circle.running {
        animation-play-state: running;
      }
      @keyframes breathe {
        0%,
        100% {
          box-shadow: 0 16px 48px rgba(124, 58, 237, 0.24);
        }
        50% {
          box-shadow: 0 24px 64px rgba(167, 139, 250, 0.28);
        }
      }
      .nap-core {
        width: 76%;
        height: 76%;
        border-radius: 50%;
        background: #fff;
        display: grid;
        place-items: center;
        text-align: center;
        padding: 1rem 1.25rem;
        box-shadow: inset 0 0 0 1px rgba(2, 6, 23, 0.06);
      }
      .countdown {
        font-size: clamp(2.2rem, 4.2vw, 3.2rem);
        font-weight: 900;
        letter-spacing: 0.5px;
        line-height: 1;
      }
      .status {
        color: var(--muted);
        font-size: 0.95rem;
        margin-top: 0.25rem;
      }

      .controls {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        justify-content: center;
        margin-top: 0.75rem;
      }
      .btn-violet {
        background: var(--violet);
        color: #fff;
        border: none;
        border-radius: 9999px;
        padding: 0.6rem 1rem;
        font-weight: 600;
      }
      .btn-violet:hover {
        background: var(--violet-600);
      }
      .btn-ghost {
        background: #fff;
        border: 1px solid var(--violet-300);
        color: var(--violet-600);
        border-radius: 9999px;
        padding: 0.55rem 0.95rem;
        font-weight: 600;
      }
      .btn-ghost:hover {
        background: #f5f3ff;
      }

      /* Right panel */
      .panel {
        background: #ffffffc4;
        border: 1px solid rgba(2, 6, 23, 0.06);
        border-radius: 18px;
        padding: 18px;
      }
      .panel h5 {
        margin: 0 0 0.5rem 0;
        font-weight: 800;
        color: #312e81;
      }

      .presets {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
      }
      .chip {
        border-radius: 9999px;
        padding: 0.4rem 0.8rem;
        font-weight: 700;
        cursor: pointer;
        background: #eef2ff;
        color: #4f46e5;
        border: 1px solid #c7d2fe;
      }
      .chip:hover {
        background: #e0e7ff;
      }
      .chip.active {
        background: #c7d2fe;
      }

      .inline {
        display: flex;
        align-items: center;
        gap: 0.6rem;
        margin-top: 0.75rem;
      }
      .inline input {
        width: 5.5rem;
        text-align: center;
      }

      .quote {
        margin-top: 0.8rem;
        font-style: italic;
        color: #475569;
        font-size: 0.95rem;
        display: flex;
        gap: 0.5rem;
        align-items: flex-start;
      }

      /* --- Sleep Music mini player --- */
      .nap-mini {
        display: flex;
        gap: 12px;
        align-items: center;
        border: 1px solid rgba(2, 6, 23, 0.06);
        background: #ffffffc4;
        border-radius: 12px;
        padding: 12px;
      }
      .nap-mini img {
        width: 56px;
        height: 56px;
        object-fit: cover;
        border-radius: 8px;
        background: #f3f3f3;
      }
      .nap-mini .meta {
        display: flex;
        flex-direction: column;
        min-width: 0;
      }
      .nap-mini .title {
        font-weight: 700;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .nap-mini .sub {
        color: #666;
        font-size: 0.95rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .nap-mini .actions {
        margin-left: auto;
        display: flex;
        gap: 8px;
        align-items: center;
      }
      .nap-mini .btn {
        padding: 0.45rem 0.8rem;
        border-radius: 999px;
        border: 1px solid #ddd;
        background: #fafafa;
        cursor: pointer;
      }
      .nap-mini .primary {
        background: var(--violet);
        color: #fff;
        border-color: transparent;
        text-decoration: none;
      }
      .nap-mini .status {
        color: #555;
        margin-top: 4px;
        min-height: 1.2em;
      }

      /* Chatbot bubble icon */
      #chatbot-toggle {
        position: fixed;
        bottom: 80px;
        right: 30px;
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background-color: #d6b3ff;
        color: white;
        border: none;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        z-index: 1000;
        transition: all 0.3s ease;
      }
      /* chat bot icon hoover color */
      #chatbot-toggle:hover {
        background-color: #c59aff;
        transform: scale(1.1);
      }
      /* the chatbox */
      #chatbot-window {
        position: fixed;
        bottom: 100px;
        right: 30px;
        width: 380px;
        height: 550px;
        background: white;
        border-radius: 16px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
        display: none;
        flex-direction: column;
        z-index: 1000;
        overflow: hidden;
      }
      /* open window */
      #chatbot-window.open {
        display: flex;
      }
      /* header in the chat box */
      .chatbot-header {
        background: linear-gradient(135deg, #d6b3ff 0%, #c59aff 100%);
        color: white;
        padding: 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .chatbot-header h5 {
        margin: 0;
        font-weight: 600;
      }
      /* To close the chatbox */
      .chatbot-close {
        background: none;
        border: none;
        color: white;
        font-size: 24px;
        cursor: pointer;
        padding: 0;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: background 0.2s;
      }
      .chatbot-close:hover {
        background: rgba(255, 255, 255, 0.2);
      }
      /* sending message and the text bubbles */
      .chatbot-messages {
        flex: 1;
        padding: 20px;
        overflow-y: auto;
        background: #f8f9fa;
      }
      .message {
        margin-bottom: 16px;
        display: flex;
        gap: 10px;
      }
      /* Ai and user icon in text chat */
      .message.user {
        flex-direction: row-reverse;
      }
      .message-avatar {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
        font-size: 18px;
      }
      .message.bot .message-avatar {
        background: #d6b3ff;
        color: white;
      }
      .message.user .message-avatar {
        background: #6c757d;
        color: white;
      }
      /* the text bubble */
      .message-content {
        max-width: 70%;
        padding: 12px 16px;
        border-radius: 16px;
        word-wrap: break-word;
      }

      .message.bot .message-content {
        background: white;
        border-bottom-left-radius: 4px;
      }

      .message.user .message-content {
        background: #d6b3ff;
        color: white;
        border-bottom-right-radius: 4px;
      }
      /* AI message critera */
      .chatbot-input-area {
        padding: 16px;
        background: white;
        border-top: 1px solid #e9ecef;
      }

      .chatbot-input-wrapper {
        display: flex;
        gap: 10px;
      }

      .chatbot-input {
        flex: 1;
        padding: 12px 16px;
        border: 2px solid #e9ecef;
        border-radius: 24px;
        outline: none;
        transition: border-color 0.2s;
      }

      .chatbot-input:focus {
        border-color: #d6b3ff;
      }

      .chatbot-send {
        width: 44px;
        height: 44px;
        border-radius: 50%;
        background-color: #d6b3ff;
        color: white;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background 0.2s;
      }

      .chatbot-send:hover:not(:disabled) {
        background-color: #c59aff;
      }

      .chatbot-send:disabled {
        background-color: #e9ecef;
        cursor: not-allowed;
      }
      /* user typing area */
      .typing-indicator {
        display: flex;
        gap: 4px;
        padding: 12px 16px;
      }

      .typing-dot {
        width: 8px;
        height: 8px;
        background: #6c757d;
        border-radius: 50%;
        animation: typing 1.4s infinite;
      }

      .typing-dot:nth-child(2) {
        animation-delay: 0.2s;
      }

      .typing-dot:nth-child(3) {
        animation-delay: 0.4s;
      }
      /* allow typing in the chatbot */
      @keyframes typing {
        0%,
        60%,
        100% {
          opacity: 0.3;
          transform: translateY(0);
        }
        30% {
          opacity: 1;
          transform: translateY(-10px);
        }
      }

      @media (max-width: 480px) {
        #chatbot-window {
          width: calc(100vw - 20px);
          right: 10px;
          bottom: 90px;
          height: 500px;
        }
      }
    </style>
  </head>

  <body class="layout-fixed sidebar-expand-lg bg-body-tertiary">
    <div class="app-wrapper">
      <!-- Navigation and sidebar placeholders -->
      <nav id="nav-placeholder" class="app-header navbar navbar-expand bg-body">
        <!-- Empty -->
      </nav>

      <aside
        id="sidebar-placeholder"
        class="app-sidebar bg-body-secondary shadow"
        data-bs-theme="dark"
      >
        <!-- Empty -->
      </aside>

      <!-- Main -->
      <main class="app-main">
        <!-- ambient background blobs -->
        <div class="ambient" aria-hidden="true">
          <div class="blob violet"></div>
          <div class="blob sky"></div>
        </div>

        <div class="center-wrap">
          <div class="glass">
            <!-- LEFT: circle -->
            <section aria-label="Nap timer">
              <div class="nap-circle" id="napCircle">
                <div class="nap-core">
                  <div id="countdown" class="countdown" aria-live="polite">
                    20:00
                  </div>
                  <div id="status" class="status">Ready to nap</div>
                  <div class="controls">
                    <button id="startPauseBtn" class="btn-violet">
                      <i class="bi bi-play-fill me-1"></i><span>Start</span>
                    </button>
                    <button id="resetBtn" class="btn-ghost">
                      <i class="bi bi-arrow-counterclockwise me-1"></i>Reset
                    </button>
                  </div>
                </div>
              </div>
            </section>

            <!-- RIGHT: presets + quote  -->
            <aside class="panel" aria-label="Nap options">
              <h5><i class="bi bi-stars me-2"></i>Quick presets</h5>
              <div class="presets" id="presets">
                <button class="chip active" data-min="15">15 min</button>
                <button class="chip" data-min="20">20 min</button>
                <button class="chip" data-min="30">30 min</button>
              </div>

              <div class="inline">
                <label for="durationMin" class="form-label m-0">Custom</label>
                <input
                  id="durationMin"
                  type="number"
                  class="form-control form-control-sm"
                  min="1"
                  max="180"
                  value="20"
                />
                <span>min</span>
              </div>

              <div class="quote">
                <i class="bi bi-quote"></i>
                <div id="quoteText">‚ÄúA short nap can refuel your day.‚Äù</div>
              </div>
            </aside>
            <!-- Kate Dinh adds for sleepMusic -->
            <!-- Sleep Music mini player (spans both columns) -->
            <section
              class="nap-mini"
              style="grid-column: 1 / -1"
              aria-label="Sleep music mini player"
            >
              <img id="napMiniImg" alt="cover" />
              <div class="meta">
                <div class="title" id="napMiniTitle">No track selected</div>
                <div class="sub" id="napMiniSub">
                  Rain ‚Äî 30s preview ‚Ä¢ Loop: On
                </div>
                <div class="status" id="napMiniStatus"></div>
              </div>
              <div class="actions">
                <button class="btn" id="napMiniPlay">
                  <i class="bi bi-play-fill me-1"></i>Play
                </button>
                <button class="btn" id="napMiniPause">
                  <i class="bi bi-pause-fill me-1"></i>Pause
                </button>
                <a
                  class="btn primary"
                  href="./sleepMusic.html?return=/nappingPage.html"
                >
                  <i class="bi bi-music-note-list me-1"></i>Change music
                </a>
              </div>
              <audio id="napMiniAudio" preload="auto"></audio>
            </section>
          </div>
        </div>

        <!-- Chatbot UI -->
        <button id="chatbot-toggle" aria-label="Open chatbot">
          <i class="bi bi-chat-dots-fill"></i>
        </button>
        <!--header for chat-->
        <div id="chatbot-window">
          <div class="chatbot-header">
            <h5><i class="bi bi-robot me-2"></i>Napster AI Assistant</h5>
            <button
              class="chatbot-close"
              id="chatbot-close"
              aria-label="Close chatbot"
            >
              <i class="bi bi-x"></i>
            </button>
          </div>
          <!--Beginning message-->
          <div class="chatbot-messages" id="chatbot-messages">
            <div class="message bot">
              <div class="message-avatar">
                <i class="bi bi-robot"></i>
              </div>
              <div class="message-content">
                Hi! I'm your Napster AI assistant. How can I help you with your
                sleep and nap schedule today?
              </div>
            </div>
          </div>
          <!--Chatbot message sender-->
          <div class="chatbot-input-area">
            <div class="chatbot-input-wrapper">
              <input
                type="text"
                class="chatbot-input"
                id="chatbot-input"
                placeholder="Type your message..."
                autocomplete="off"
              />
              <button
                class="chatbot-send"
                id="chatbot-send"
                aria-label="Send message"
              >
                <i class="bi bi-send-fill"></i>
              </button>
            </div>
          </div>
        </div>

        <footer class="app-footer">
          <div class="float-end d-none d-sm-inline">Dream More. Do More.</div>
          <strong>Copyright &copy; 2025&nbsp;</strong> All rights reserved.
        </footer>
      </main>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/overlayscrollbars@2.10.1/browser/overlayscrollbars.browser.es6.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.min.js"></script>
    <script src="../../dist/js/adminlte.js"></script>

    <script>
      // Sidebar scrollbars
      document.addEventListener("DOMContentLoaded", () => {
        const sidebarWrapper = document.querySelector(".sidebar-wrapper");
        if (
          sidebarWrapper &&
          typeof OverlayScrollbarsGlobal?.OverlayScrollbars !== "undefined"
        ) {
          OverlayScrollbarsGlobal.OverlayScrollbars(sidebarWrapper, {
            scrollbars: {
              theme: "os-theme-light",
              autoHide: "leave",
              clickScroll: true,
            },
          });
        }
      });

      // Auth display (safe if endpoint exists)
      fetch("/api/user")
        .then((res) => {
          if (res.status === 401) {
            location.href = "/signin";
            return null;
          }
          return res.json();
        })
        .then(
          (d) =>
            d?.username &&
            document
              .querySelectorAll(".username-display")
              .forEach((el) => (el.textContent = d.username))
        )
        .catch(() => {});
      document.getElementById("logout-btn")?.addEventListener("click", () => {
        fetch("/logout", { method: "POST" }).then(
          () => (location.href = "/signin")
        );
      });
    </script>

    <!-- Nap logic  -->
    <script>
      (function () {
        const circle = document.getElementById("napCircle");
        const countdownEl = document.getElementById("countdown");
        const statusEl = document.getElementById("status");
        const startPauseBtn = document.getElementById("startPauseBtn");
        const resetBtn = document.getElementById("resetBtn");
        const durationInput = document.getElementById("durationMin");
        const presetsEl = document.getElementById("presets");

        const STATE = { IDLE: "idle", RUNNING: "running", PAUSED: "paused" };
        let state = STATE.IDLE;
        let durationSec = 0;
        let remainingSec = 0;
        let timerId = null;
        let startedAt = null;
        let currNapID = null;

        fetch("/api/naplen")
          .then((res) => res.json())
          .then((data) => {
            const naplen = data.preferrednaplen / 60; // if DB is in seconds
            durationSec = data.preferrednaplen;
            remainingSec = durationSec;
            durationInput.value = naplen;
            countdownEl.textContent = fmt(data.preferrednaplen);
          });

        // Soft quotes
        const quotes = [
          "‚ÄúA short nap can refuel your day.‚Äù",
          "‚ÄúRest is part of the work.‚Äù",
          "‚ÄúClose eyes, open focus.‚Äù",
          "‚ÄúTwenty minutes to reset.‚Äù",
        ];
        document.getElementById("quoteText").textContent =
          quotes[Math.floor(Math.random() * quotes.length)];

        function fmt(sec) {
          const m = String(Math.floor(sec / 60)).padStart(2, "0");
          const s = String(sec % 60).padStart(2, "0");
          return m + ":" + s;
        }
        function setProgress() {
          const pct = 100 * (1 - remainingSec / durationSec);
          circle.style.setProperty("--progress", pct + "%");
        }
        function render() {
          countdownEl.textContent = fmt(remainingSec);
          setProgress();
        }

        function setState(next) {
          state = next;
          if (state === STATE.IDLE) {
            circle.classList.remove("running");
            statusEl.textContent = "Ready to nap";
            startPauseBtn.innerHTML =
              '<i class="bi bi-play-fill me-1"></i>Start';
          } else if (state === STATE.RUNNING) {
            circle.classList.add("running");
            statusEl.textContent = "Napping...";
            startPauseBtn.innerHTML =
              '<i class="bi bi-pause-fill me-1"></i>Pause';
          } else {
            circle.classList.remove("running");
            statusEl.textContent = "Paused";
            startPauseBtn.innerHTML =
              '<i class="bi bi-play-fill me-1"></i>Resume';
          }
        }

        async function start() {
          if (state === STATE.RUNNING) return;
          if (state === STATE.IDLE) {
            durationSec = (Number(durationInput.value) || 20) * 60;
            remainingSec = durationSec;
            startedAt = new Date().toISOString();

            try {
              const res = await fetch("/api/startNap", {
                method: "POST",
              });

              if (!res.ok) {
                alert("‚ùå " + "failed to start nap");
                return;
              }

              if (res.ok) {
                const data = await res.json(); // <- parses { napID }
                currNapID = data.napID;
              }
            } catch (err) {
              console.error(err);
            }
          }
          timerId = setInterval(tick, 1000);
          setState(STATE.RUNNING);
          render();
        }
        function pause() {
          if (timerId) {
            clearInterval(timerId);
            timerId = null;
          }
          setState(STATE.PAUSED);
        }
        function reset() {
          if (timerId) {
            clearInterval(timerId);
            timerId = null;
          }
          durationSec = (Number(durationInput.value) || 20) * 60;
          remainingSec = durationSec;
          startedAt = null;
          setState(STATE.IDLE);
          render();
        }

        async function finish() {
          if (timerId) {
            clearInterval(timerId);
            timerId = null;
          }
          setState(STATE.IDLE);
          statusEl.textContent = "Nap complete ‚ú®";

          const endedAt = new Date().toISOString();
          await saveNap({ startedAt, endedAt, durationSec });
          remainingSec = durationSec;
          render();
        }

        function tick() {
          if (remainingSec > 0) {
            remainingSec--;
            render();
          } else {
            finish();
          }
        }

        // UI wiring
        startPauseBtn.addEventListener("click", () =>
          state === STATE.IDLE || state === STATE.PAUSED ? start() : pause()
        );

        startPauseBtn.addEventListener("click", () => {
          localStorage.setItem("alarmStarted", "true");
        });

        resetBtn.addEventListener("click", reset);
        durationInput.addEventListener("change", () => {
          if (state === STATE.IDLE) {
            durationSec = (Number(durationInput.value) || 20) * 60;
            remainingSec = durationSec;
            render();
            presetsEl
              .querySelectorAll(".chip")
              .forEach((c) => c.classList.remove("active"));
          }
        });

        presetsEl.addEventListener("click", (e) => {
          const chip = e.target.closest(".chip");
          if (!chip) return;
          presetsEl
            .querySelectorAll(".chip")
            .forEach((c) => c.classList.remove("active"));
          chip.classList.add("active");
          durationInput.value = chip.dataset.min;
          if (state === STATE.IDLE) {
            durationSec = Number(chip.dataset.min) * 60;
            remainingSec = durationSec;
            render();
          }
        });

        // Persistence (API first, fallback localStorage)
        async function saveNap(entry) {
          try {
            const res = await fetch("/api/endNap", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({ napID: currNapID }), // üëà send JSON
            });

            if (!res.ok) {
              alert("‚ùå " + "failed to end nap");
              return;
            }

            if (res.ok) {
              const data = await res.json(); // <- parses { napID }
              currNapID = data.napID;
            }
          } catch {
            console.error(err);
            alert("‚ùå Something went wrong. Please try again.");
          }
        }

        // Init
        render();
      })();
    </script>
    <script defer src="/dist/js/headerCommon.js"></script>
    <script defer src="/dist/js/layoutLoader.js"></script>

    <!-- Sleep Music mini player logic -->
    <script>
      (() => {
        // Keys sleepMusic.html will write to
        const K = {
          preview: "nap.music.previewUrl",
          title: "nap.music.title",
          artist: "nap.music.artist",
          img: "nap.music.img",
          loop: "nap.settings.loop",
          fade: "nap.settings.fadeSec",
          auto: "nap.settings.autoStart",
        };

        const audio = document.getElementById("napMiniAudio");
        const titleEl = document.getElementById("napMiniTitle");
        const subEl = document.getElementById("napMiniSub");
        const imgEl = document.getElementById("napMiniImg");
        const statusEl = document.getElementById("napMiniStatus");

        const getBool = (k, def) => {
          const v = localStorage.getItem(k);
          if (v === null) return !!def;
          return v === "true";
        };
        const getNum = (k, def) => {
          const n = Number(localStorage.getItem(k));
          return Number.isNaN(n) ? def : n;
        };

        function refreshFromStorage() {
          const src = localStorage.getItem(K.preview) || "";
          const title = localStorage.getItem(K.title) || "";
          const artist = localStorage.getItem(K.artist) || "";
          const img = localStorage.getItem(K.img) || "";
          const loop = getBool(K.loop, true);

          // Summary: ‚ÄúRain ‚Äî 30s preview ‚Ä¢ Loop: On‚Äù
          const summaryLeft = title || "Rain";
          const summaryMid = "30s preview";
          const summaryRight = `Loop: ${loop ? "On" : "Off"}`;

          audio.src = src;
          audio.loop = loop;

          titleEl.textContent = title || "No track selected";
          subEl.textContent = `${summaryLeft} ‚Äî ${summaryMid} ‚Ä¢ ${summaryRight}`;
          imgEl.src = img || "";
          imgEl.style.visibility = img ? "visible" : "hidden";
        }

        function setStatus(t) {
          statusEl.textContent = t;
        }

        // Controls
        document
          .getElementById("napMiniPlay")
          .addEventListener("click", async () => {
            if (!audio.src) {
              setStatus("Choose music first (Change music).");
              return;
            }
            audio.loop = getBool(K.loop, true);
            try {
              await audio.play();
              setStatus("Playing");
            } catch {
              setStatus(
                "If autoplay is blocked, press Play in the player bar."
              );
            }
          });
        document
          .getElementById("napMiniPause")
          .addEventListener("click", () => {
            audio.pause();
            setStatus("Paused");
          });

        // Update on selection change from sleepMusic.html
        window.addEventListener("storage", (e) => {
          if ([K.preview, K.title, K.artist, K.img, K.loop].includes(e.key)) {
            refreshFromStorage();
            setStatus("Selection updated");
          }
        });

        // Initial load
        refreshFromStorage();
      })();
    </script>

    <script>
      let awaitingSaveConfirmation = false;

      // Chatbot functionality
      const chatbotToggle = document.getElementById("chatbot-toggle");
      const chatbotWindow = document.getElementById("chatbot-window");
      const chatbotClose = document.getElementById("chatbot-close");
      const chatbotInput = document.getElementById("chatbot-input");
      const chatbotSend = document.getElementById("chatbot-send");
      const chatbotMessages = document.getElementById("chatbot-messages");

      // Toggle chatbot window
      chatbotToggle.addEventListener("click", () => {
        chatbotWindow.classList.add("open");
        chatbotInput.focus();
      });

      chatbotClose.addEventListener("click", () => {
        chatbotWindow.classList.remove("open");
      });

      // Add message to chat
      function addMessage(text, isUser = false) {
        const messageDiv = document.createElement("div");
        messageDiv.className = `message ${isUser ? "user" : "bot"}`;

        const avatar = document.createElement("div");
        avatar.className = "message-avatar";
        avatar.innerHTML = isUser
          ? '<i class="bi bi-person-fill"></i>'
          : '<i class="bi bi-robot"></i>';

        const content = document.createElement("div");
        content.className = "message-content";
        content.textContent = text;

        messageDiv.appendChild(avatar);
        messageDiv.appendChild(content);
        chatbotMessages.appendChild(messageDiv);

        // Scroll to bottom
        chatbotMessages.scrollTop = chatbotMessages.scrollHeight;
      }

      // Show typing indicator
      function showTypingIndicator() {
        const typingDiv = document.createElement("div");
        typingDiv.className = "message bot";
        typingDiv.id = "typing-indicator";

        const avatar = document.createElement("div");
        avatar.className = "message-avatar";
        avatar.innerHTML = '<i class="bi bi-robot"></i>';

        const content = document.createElement("div");
        content.className = "message-content typing-indicator";
        content.innerHTML =
          '<div class="typing-dot"></div><div class="typing-dot"></div><div class="typing-dot"></div>';

        typingDiv.appendChild(avatar);
        typingDiv.appendChild(content);
        chatbotMessages.appendChild(typingDiv);
        chatbotMessages.scrollTop = chatbotMessages.scrollHeight;
      }

      function removeTypingIndicator() {
        const indicator = document.getElementById("typing-indicator");
        if (indicator) {
          indicator.remove();
        }
      }

      // Handle sending messages
      async function sendMessage() {
        const message = chatbotInput.value.trim();
        if (!message) return;

        // Add user message
        addMessage(message, true);
        chatbotInput.value = "";
        chatbotSend.disabled = true;

        // Show typing indicator
        showTypingIndicator();

        setTimeout(() => {
          removeTypingIndicator();

          addMessage(randomResponse, false);
          chatbotSend.disabled = false;
          chatbotInput.focus();
        }, 1500);
      }

      async function fetchRecommendations() {
        try {
          const res = await fetch("api/recommendations");
          const data = await res.json();

          removeTypingIndicator();

          if (!Array.isArray(data) || data.length === 0) {
            addMessage(
              "I couldn't find any recommended nap times based on your availability.",
              false
            );
            return;
          }

          let text = "Here are your personalized recommended nap times:\n\n";

          for (const rec of data) {
            text += `‚Ä¢ ${rec.day}: ${rec.time}\n`;
          }

          addMessage(text, false);
          addMessage(
            "Would you like me to save these nap times for you?",
            false
          );

          console.log("RECOMMENDATIONS:");
          console.log(data);

          awaitingSaveConfirmation = true;
          window.lastRecommendations = data; // save it temporarily
        } catch (err) {
          console.error(err);
          removeTypingIndicator();
          addMessage(
            "Sorry! I had trouble fetching your nap recommendations.",
            false
          );
        }
      }

      async function saveNapTimes() {
        showTypingIndicator();

        try {
          const dayMap = {
            Sunday: 0,
            Monday: 1,
            Tuesday: 2,
            Wednesday: 3,
            Thursday: 4,
            Friday: 5,
            Saturday: 6,
          };

          const parseTime = (t) => {
            let [hour, minPart] = t.split(":");
            const min = parseInt(minPart);
            let isPM = t.toLowerCase().includes("pm");

            hour = parseInt(hour);

            if (isPM && hour !== 12) hour += 12;
            if (!isPM && hour === 12) hour = 0;

            return `${hour.toString().padStart(2, "0")}:${min
              .toString()
              .padStart(2, "0")}:00`;
          };

          // Convert recommendations into backend format
          const naps = window.lastRecommendations.map((r) => {
            const [startStr, endStr] = r.time.split("‚Äì").map((s) => s.trim());

            return {
              day: dayMap[r.day],
              startTime: parseTime(startStr),
              endTime: parseTime(endStr),
            };
          });

          console.log("Parsed naps:", naps);

          const res = await fetch("/api/napSchedule", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ naps }),
          });

          const data = await res.json();

          removeTypingIndicator();

          if (data.success) {
            addMessage(
              "Your nap schedule has been saved successfully! üòÑ",
              false
            );
          } else {
            addMessage("Something went wrong saving your nap times.", false);
          }
        } catch (err) {
          console.error("Save error:", err);
          removeTypingIndicator();
          addMessage("Sorry, I had trouble saving your nap schedule.", false);
        }
      }
      // Smart response generator
      function generateResponse(userMessage) {
        const message = userMessage.toLowerCase();

        if (
          message.includes("recommend") ||
          message.includes("suggest") ||
          message.includes("nap schedule") ||
          message.includes("when should i nap") ||
          message.includes("best time to nap")
        ) {
          return "__FETCH_RECOMMENDATIONS__";
        }

        // Nap duration questions
        if (
          message.includes("how long") &&
          (message.includes("nap") || message.includes("sleep"))
        ) {
          return "The ideal nap length depends on your goals: 10-20 minutes for a quick power nap, 60 minutes for memory boost, or 90 minutes for a full sleep cycle. What works best for you?";
        }

        // Nap timing questions
        if (
          (message.includes("when") || message.includes("what time")) &&
          message.includes("nap")
        ) {
          return "The best time to nap is typically between 1-3 PM, when your body naturally experiences an afternoon dip in energy. Avoid napping after 4 PM as it might interfere with nighttime sleep.";
        }

        // Benefits questions
        if (
          message.includes("benefit") ||
          (message.includes("why") && message.includes("nap"))
        ) {
          return "Napping can improve alertness, boost mood, enhance performance, increase creativity, and help with memory consolidation. Even a short 20-minute nap can make a big difference!";
        }

        // Sleep problems
        if (
          message.includes("cant sleep") ||
          message.includes("can't sleep") ||
          message.includes("insomnia")
        ) {
          return "If you're having trouble sleeping, try: maintaining a consistent sleep schedule, avoiding caffeine 6 hours before bed, keeping your room cool and dark, and limiting screen time before sleep. Would you like more specific tips?";
        }

        // Alarm/wake up questions
        if (
          message.includes("alarm") ||
          (message.includes("wake") && !message.includes("up"))
        ) {
          return "You can set an alarm using the purple Alarm button on the home page! It will help ensure you don't oversleep your nap. Would you like tips on optimal nap durations?";
        }

        // Schedule questions
        if (message.includes("schedule") || message.includes("plan")) {
          return "Check out your Nap Schedule page from the sidebar! You can view and plan your naps there. A consistent schedule helps train your body for better rest.";
        }

        // History questions
        if (
          message.includes("history") ||
          message.includes("track") ||
          message.includes("log")
        ) {
          return "You can view your nap history in the Nap History page from the sidebar. Tracking your naps helps you understand your sleep patterns better!";
        }

        // Dashboard questions
        if (
          message.includes("dashboard") ||
          message.includes("stats") ||
          message.includes("data")
        ) {
          return "Visit the Dashboard page to see your sleep statistics and insights! It provides a comprehensive overview of your napping patterns.";
        }

        // Power nap
        if (message.includes("power nap")) {
          return "A power nap is a short 10-20 minute nap that boosts alertness without entering deep sleep. It's perfect for a quick energy boost during the day!";
        }

        // Greetings
        if (
          message.includes("hello") ||
          message.includes("hi ") ||
          message === "hi" ||
          message.includes("hey")
        ) {
          return "Hello! How can I help you optimize your naps and sleep today? üòä";
        }

        // Thanks
        if (message.includes("thank") || message.includes("thanks")) {
          return "You're welcome! Let me know if you need any other sleep or nap advice. Sweet dreams! üí§";
        }

        // Goodbye
        if (message.includes("bye") || message.includes("goodbye")) {
          return "Goodbye! Rest well and happy napping! üåô";
        }

        // Default responses for unrelated questions
        const defaultResponses = [
          "That's an interesting question about sleep! While I'm still learning, I can help you with nap schedules, optimal nap times, and sleep tips. What would you like to know?",
          "I'm here to help with your napping needs! Try asking me about ideal nap duration, best times to nap, or check your nap history and schedule in the sidebar.",
          "Good question! I specialize in nap and sleep advice. Would you like to know about power naps, sleep cycles, or how to use the Napster features?",
          "I can help you with nap-related questions! Try asking about nap benefits, timing, duration, or explore the Dashboard and Nap History pages for insights.",
        ];

        return defaultResponses[
          Math.floor(Math.random() * defaultResponses.length)
        ];
      }

      // Handle sending messages
      async function sendMessage() {
        const message = chatbotInput.value.trim();
        if (!message) return;

        // Add user message
        addMessage(message, true);
        chatbotInput.value = "";
        chatbotSend.disabled = true;

        // Show typing indicator
        showTypingIndicator();

        // Simulate thinking time
        const thinkingTime = 800 + Math.random() * 700;

        setTimeout(() => {
          removeTypingIndicator();

          // Check if we are awaiting user confirmation to save
          if (awaitingSaveConfirmation) {
            const lower = message.toLowerCase();

            if (
              lower.includes("yes") ||
              lower.includes("save") ||
              lower.includes("sure")
            ) {
              awaitingSaveConfirmation = false;
              saveNapTimes(); // <-- we'll define this next
              return;
            }

            if (
              lower.includes("no") ||
              lower.includes("not") ||
              lower.includes("don't")
            ) {
              awaitingSaveConfirmation = false;
              addMessage(
                "Okay! I won't save them. Let me know if you change your mind!",
                false
              );
              return;
            }

            // If they typed something else, ask again politely
            addMessage(
              "Sorry, I didn't catch that ‚Äî would you like me to save your nap times?",
              false
            );
            return;
          }

          // Generate response
          const response = generateResponse(message);

          // If chatbot needs to fetch recommendation from backend
          if (response === "__FETCH_RECOMMENDATIONS__") {
            fetchRecommendations();
          } else {
            addMessage(response, false);
          }

          chatbotSend.disabled = false;
          chatbotInput.focus();
        }, thinkingTime);
      }

      // Event listeners for sending messages
      chatbotSend.addEventListener("click", sendMessage);

      chatbotInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          sendMessage();
        }
      });

      // Enable/disable send button based on input
      chatbotInput.addEventListener("input", () => {
        chatbotSend.disabled = !chatbotInput.value.trim();
      });
    </script>
  </body>
</html>
